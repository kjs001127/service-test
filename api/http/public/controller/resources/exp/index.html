<!DOCTYPE html>
<html>
  <head>
    <title></title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <style>
      body {
        margin: 0;
        width: 100%;
        height: 100vh;
      }
      #wam {
        width: 100%;
        height: 100%;
        border: none;
        display: block;
      }
    </style>
  </head>
  <body>
    <script>
      function flattenObject(obj) {
        const result = {};

        for (const key in obj) {
          if (obj.hasOwnProperty(key)) {
            if (typeof obj[key] === 'object' && obj[key] !== null && !Array.isArray(obj[key])) {
              for (const nestedKey in obj[key]) {
                if (obj[key].hasOwnProperty(nestedKey)) {
                  result[nestedKey] = obj[key][nestedKey];
                }
              }
            } else {
              result[key] = obj[key];
            }
          }
        }

        return result;
      }
    </script>
    <script>
      const wamData = (() => {
        try {
          const searchParams = new URLSearchParams(window.location.search)
          const decodedWamData = searchParams.get('wam_data')
          const parsedWamData = JSON.parse(decodedWamData)
          const flattenedWamData = flattenObject(parsedWamData)
          return flattenedWamData
        } catch (e) {
          return {}
        }
      })()

      const baseAppStoreUrl = 'https://app-store-api.exp.channel.io'

      function sendToClient(wamEvent) {
        if (
          window.channelMobileWamController &&
          typeof window.channelMobileWamController.postMessage === 'function'
        ) {
          window.channelMobileWamController.postMessage(JSON.stringify(wamEvent))
          return
        }
      
        if (
          window.webkit &&
          window.webkit.messageHandlers &&
          window.webkit.messageHandlers.channelMobileWamController &&
          typeof window.webkit.messageHandlers.channelMobileWamController.postMessage === 'function'
        ) {
          window.webkit.messageHandlers.channelMobileWamController.postMessage(wamEvent)
          return
        }

        if (
          window.parent &&
          window.parent.postMessage &&
          typeof window.parent.postMessage === 'function'
        ) {
          window.parent.postMessage(wamEvent, '*')
        }
      }

      function close({ appId, name, params = {} } = {}) {
        const wamEvent = appId && name ? {
          type: 'command',
          wamId: wamData.wamId,
          attributes: {
            appId,
            name,
            params,
          }
        } : null

        sendToClient({
          type: 'close',
          wamId: wamData.wamId,
          attributes: {
            wamEvent,
          }
        })
      }

      function callCommand({ appId, name, params = {} } = {}) {
        sendToClient({
          type: 'command',
          wamId: wamData.wamId,
          attributes: {
            appId,
            name,
            params,
          }
        })
      }

      function setSize({ width, height }) {
        sendToClient({
          type: 'setSize',
          wamId: wamData.wamId,
          attributes: {
            width,
            height,
          }
        })
      }

      function refreshAuthToken() {
        return fetch(`${baseAppStoreUrl}/general/v1/token/refresh`, {
          method: 'PUT',
          body: JSON.stringify({
            refreshToken: wamData.refreshToken,
          })
        })
        .then(response => response.json())
      }

      /**
       * @author: daniel
       * @description: token이 invalid 할 경우, token refresh후 다시 function을 호출해 줌.
       * 하지만 function이 token invalid가 아닌 다른 요인으로 에러가 발생했을 경우 재호출된 function은
       * 다시 실패할 가능성이 높으며 무한루프가 돌게 됨.
       * 명확하게 token invalid에러가 발생했을 경우만 token refresh를 해줘야 하지만 현재는 서버에서 구분할
       * 수 있는 값을 내려주지 않고 있기 때문에 임시로 클라이언트에서 request retry 횟수를 제한함.
       */
      let functionRetry = 0
      let nativeFunctionRetry = 0

      function callFunction({ appId, name, params = {} } = {}) {
        return fetch(`${baseAppStoreUrl}/general/v1/apps/${appId}/functions`, {
          method: 'PUT',
          body: JSON.stringify({
            method: name,
            params,
            context: {
              channel: {
                id: wamData.channelId,
              }
            }
          }),
          headers: {
            'x-access-token': wamData.accessToken,
            'accept': 'application/json',
            'Content-Type': 'application/json',
          }
        })
        .then(response => {
          if (!response.ok && functionRetry < 3) {
            functionRetry += 1

            return response.json().then((error) => {
              return refreshAuthToken()
                .then((result) => {
                  if (result && result.access_token && result.refresh_token) {
                    wamData.accessToken = result.access_token
                    wamData.refreshToken = result.refresh_token

                    sendToClient({
                      type: 'onAuthTokenUpdated',
                      wamId: wamData.wamId,
                      attributes: result,
                    })
                    return callFunction({ appId, name, params })
                  }
                })
            })
          }
          functionRetry = 0

          return response.json()
        })
      }

      function callNativeFunction({ name, params = {}}) {
        return fetch(`${baseAppStoreUrl}/general/v1/native/functions`, {
          method: 'PUT',
          body: JSON.stringify({
            method: name,
            params,
          }),
          headers: {
            'x-access-token': wamData.accessToken,
            'accept': 'application/json',
            'Content-Type': 'application/json',
          }
        })
        .then(response => {
          if (!response.ok && nativeFunctionRetry < 3) {
            nativeFunctionRetry += 1

            return response.json().then((error) => {
              return refreshAuthToken()
                .then((result) => {
                  if (result && result.access_token && result.refresh_token) {
                    wamData.accessToken = result.access_token
                    wamData.refreshToken = result.refresh_token

                    sendToClient({
                      type: 'onAuthTokenUpdated',
                      wamId: wamData.wamId,
                      attributes: result,
                    })
                    return callNativeFunction({ name, params })
                  }
                })
            })
          }
          nativeFunctionRetry = 0

          return response.json()
        })
      }

      function getWamData(key) {
        return wamData[key]
      }

      function getVersion() {
        return 'v1'
      }

      function loadWam() {
        const wamIframe = document.createElement('iframe')
        wamIframe.id = 'wam'
        wamIframe.src = `${baseAppStoreUrl}/public/v1/apps/${wamData.appId}/wams/${wamData.wamName !== '' ? `${wamData.wamName}/` : ''}`
        document.body.appendChild(wamIframe)

        if (!wamIframe.contentWindow.ChannelIOWam) {
          wamIframe.contentWindow.ChannelIOWam = {}
        }

        wamIframe.contentWindow.ChannelIOWam.close = close
        wamIframe.contentWindow.ChannelIOWam.callCommand = callCommand
        wamIframe.contentWindow.ChannelIOWam.setSize = setSize
        wamIframe.contentWindow.ChannelIOWam.callFunction = callFunction
        wamIframe.contentWindow.ChannelIOWam.callNativeFunction = callNativeFunction
        wamIframe.contentWindow.ChannelIOWam.getWamData = getWamData
        wamIframe.contentWindow.ChannelIOWam.getVersion = getVersion
        wamIframe.contentWindow.ChannelIOWam.version = getVersion()
      }

      window.onload = loadWam
    </script>
  </body>
</html>
